# Advent of Code 2023

```elixir
Mix.install([
  {:memoize, "~> 1.4"},
  {:tesla, "~> 1.8"},
  {:kino, "~> 0.11.3"}
])

Kino.configure(inspect: [limit: :infinity, charlists: :as_lists])

alias Kino, as: IO

defmodule Api do
  use Tesla
  use Memoize

  @session System.get_env("AOC_SESSION")

  plug(Tesla.Middleware.BaseUrl, "https://adventofcode.com/2023/day/")
  plug(Tesla.Middleware.Headers, [{"cookie", "session=#{@session}"}])

  defmemo get_input(day) do
    {:ok, response} = get("#{day}/input")
    response.body
  end
end

:ok
```

## Task 1

```elixir
test_input = """
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
"""

solve1 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn line ->
    numbers = Regex.scan(~r/[1-9]/, line)
    first = List.first(numbers)
    last = List.last(numbers)
    String.to_integer("#{first}#{last}")
  end)
  |> Enum.sum()
end

142 = solve1.(test_input)
solve1.(Api.get_input(1)) |> IO.inspect(label: "1.1")

test_input_2 = """
two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
"""

strings_to_numbers = %{
  "one" => "1",
  "two" => "2",
  "three" => "3",
  "four" => "4",
  "five" => "5",
  "six" => "6",
  "seven" => "7",
  "eight" => "8",
  "nine" => "9"
}

string_to_number = fn string -> strings_to_numbers[string] || string end

solve2 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn line ->
    regex = ~r/(?=([1-9]|#{strings_to_numbers |> Map.keys() |> Enum.join("|")}))/
    numbers = regex |> Regex.scan(line, capture: :all_but_first) |> List.flatten()
    first = numbers |> List.first() |> string_to_number.()
    last = numbers |> List.last() |> string_to_number.()
    String.to_integer("#{first}#{last}")
  end)
  |> Enum.sum()
end

281 = solve2.(test_input_2)
443 = solve2.(test_input_2 <> "\nsevenine" <> "\neighthree")
solve2.(Api.get_input(1)) |> IO.inspect(label: "1.2")

:ok
```

## Task 2

```elixir
test_input = """
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
"""

max = %{
  "r" => 12,
  "g" => 13,
  "b" => 14
}

solve1 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.with_index(1)
  |> Enum.map(fn {game, id} ->
    Regex.scan(~r/(\d*) ([r|g|b])/, game, capture: :all_but_first)
    |> Enum.all?(fn [count, colour] -> String.to_integer(count) <= max[colour] end)
    |> case do
      true -> id
      false -> 0
    end
  end)
  |> Enum.sum()
end

8 = solve1.(test_input)
solve1.(Api.get_input(2)) |> IO.inspect(label: "2.1")

solve2 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn game ->
    Regex.scan(~r/(\d*) ([r|g|b])/, game, capture: :all_but_first)
    |> Enum.group_by(fn [_, colour] -> colour end, fn [count, _] -> String.to_integer(count) end)
    |> Enum.map(fn {_colour, counts} -> Enum.max(counts) end)
    |> Enum.product()
  end)
  |> Enum.sum()
end

2286 = solve2.(test_input)
solve2.(Api.get_input(2)) |> IO.inspect(label: "2.2")

:ok
```

## Task 3

```elixir
test_input = """
467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
"""

solve1 = fn input ->
  [{map_width, _}] = Regex.run(~r/\n/, input, return: :index)

  parsed_input = String.replace(input, "\n", "")

  parsed_input
  |> String.split("", trim: true)
  |> Enum.with_index()
  |> Enum.reduce({"", [], []}, fn {char, idx}, {number, indices, numbers} ->
    if char =~ ~r/\d/ do
      {number <> char, indices ++ [idx], numbers}
    else
      line = ceil(idx / map_width) - 1

      indices
      |> Enum.flat_map(fn index ->
        prev_line = [index - map_width - 1, index - map_width, index - map_width + 1]
        prev_line_range = ((line - 1) * map_width)..((line - 1) * map_width + map_width - 1)

        this_line = [index - 1, index + 1]
        this_line_range = (line * map_width)..(line * map_width + map_width - 1)

        next_line = [index + map_width - 1, index + map_width, index + map_width + 1]
        next_line_range = ((line + 1) * map_width)..((line + 1) * map_width + map_width - 1)

        Enum.filter(prev_line, &(&1 in prev_line_range and &1 > 0)) ++
          Enum.filter(this_line, &(&1 in this_line_range)) ++
          Enum.filter(next_line, &(&1 in next_line_range))
      end)
      |> Enum.any?(&(String.at(parsed_input, &1) in ~w/@ # $ % & * + - = \//))
      |> case do
        true ->
          # IO.inspect(number)
          {"", [], [String.to_integer(number) | numbers]}

        _ ->
          {"", [], numbers}
      end
    end
  end)
  |> then(fn {_, _, numbers} ->
    Enum.sum(numbers)
  end)
end

4361 = solve1.(test_input)
solve1.(Api.get_input(3)) |> IO.inspect(label: "3.1")

solve2 = fn input ->
  [{map_width, _}] = Regex.run(~r/\n/, input, return: :index)

  parsed_input = String.replace(input, "\n", "")

  parsed_input
  |> String.split("", trim: true)
  |> Enum.with_index()
  |> Enum.reduce({"", [], %{}}, fn {char, idx}, {number, indices, numbers} ->
    if char =~ ~r/\d/ do
      {number <> char, indices ++ [idx], numbers}
    else
      line = ceil(idx / map_width) - 1

      indices
      |> Enum.flat_map(fn index ->
        prev_line = [index - map_width - 1, index - map_width, index - map_width + 1]
        prev_line_range = ((line - 1) * map_width)..((line - 1) * map_width + map_width - 1)

        this_line = [index - 1, index + 1]
        this_line_range = (line * map_width)..(line * map_width + map_width - 1)

        next_line = [index + map_width - 1, index + map_width, index + map_width + 1]
        next_line_range = ((line + 1) * map_width)..((line + 1) * map_width + map_width - 1)

        Enum.filter(prev_line, &(&1 in prev_line_range and &1 > 0)) ++
          Enum.filter(this_line, &(&1 in this_line_range)) ++
          Enum.filter(next_line, &(&1 in next_line_range))
      end)
      |> Enum.find(&(String.at(parsed_input, &1) == "*"))
      |> case do
        idx when is_number(idx) ->
          {"", [],
           Map.update(
             numbers,
             idx,
             [String.to_integer(number)],
             &[String.to_integer(number) | &1]
           )}

        _ ->
          {"", [], numbers}
      end
    end
  end)
  |> then(fn {_, _, numbers} ->
    numbers
    |> Enum.filter(fn {_, v} -> length(v) == 2 end)
    |> Enum.map(fn {_, v} -> Enum.product(v) end)
    |> Enum.sum()
  end)
end

467_835 = solve2.(test_input)
solve2.(Api.get_input(3)) |> IO.inspect(label: "3.2")
```

## Task 4

```elixir
defmodule Task4 do
  def test_input,
    do: """
    Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
    Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
    Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
    Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
    Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
    Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
    """

  def solve1(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.reduce(0, fn game, acc ->
      matching_count = count_matches(game)
      floor(acc + 2 ** (matching_count - 1))
    end)
  end

  def solve2(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.with_index(1)
    |> then(fn cards ->
      cards_counts = 1..length(cards) |> Enum.map(&{&1, 1}) |> Enum.into(%{})

      Enum.reduce(cards, cards_counts, fn {card, idx}, cards_counts ->
        card
        |> count_matches()
        |> case do
          0 ->
            cards_counts

          match_count ->
            Enum.reduce((idx + 1)..(idx + match_count), cards_counts, fn match_idx,
                                                                         cards_counts ->
              Map.put(cards_counts, match_idx, cards_counts[match_idx] + cards_counts[idx])
            end)
        end
      end)
    end)
    |> Map.values()
    |> Enum.sum()
  end

  defp count_matches(card) do
    card
    |> String.split(":")
    |> List.last()
    |> String.split("|")
    |> Enum.map(&(&1 |> String.split(" ", trim: true) |> MapSet.new()))
    |> then(fn [winning, mine] -> MapSet.intersection(mine, winning) |> MapSet.size() end)
  end
end

13 = Task4.solve1(Task4.test_input())
Task4.solve1(Api.get_input(4)) |> IO.inspect(label: "4.1")

30 = Task4.solve2(Task4.test_input())
Task4.solve2(Api.get_input(4)) |> IO.inspect(label: "4.2")
```

## Task 5

```elixir
defmodule Task5 do
  def test_input,
    do: """
    seeds: 79 14 55 13

    seed-to-soil map:
    50 98 2
    52 50 48

    soil-to-fertilizer map:
    0 15 37
    37 52 2
    39 0 15

    fertilizer-to-water map:
    49 53 8
    0 11 42
    42 0 7
    57 7 4

    water-to-light map:
    88 18 7
    18 25 70

    light-to-temperature map:
    45 77 23
    81 45 19
    68 64 13

    temperature-to-humidity map:
    0 69 1
    1 0 69

    humidity-to-location map:
    60 56 37
    56 93 4
    """

  def solve1(input) do
    [seeds | map_groups] =
      input
      |> String.split("\n\n", trim: true)
      |> Enum.map(&(Regex.scan(~r/\b\d+\b/, &1) |> Enum.map(fn [a] -> String.to_integer(a) end)))

    map_groups = Enum.map(map_groups, &Enum.chunk_every(&1, 3))

    seeds
    |> Enum.map(fn seed ->
      Enum.reduce(map_groups, seed, fn maps, current_range ->
        Enum.reduce_while(maps, current_range, fn map, current_value ->
          [dest, src, count] = map

          if src <= current_value and current_value < src + count do
            {:halt, dest + current_value - src}
          else
            {:cont, current_value}
          end
        end)
      end)
    end)
    |> Enum.min()
  end

  def solve2(input) do
    [seeds | map_groups] =
      input
      |> String.split("\n\n", trim: true)
      |> Enum.map(&(Regex.scan(~r/\b\d+\b/, &1) |> Enum.map(fn [a] -> String.to_integer(a) end)))

    seeds_ranges =
      Enum.chunk_every(seeds, 2)
      |> Enum.map(fn [start, count] -> [start, start + count - 1] end)

    # |> Enum.map(&MapSet.new/1)

    map_groups = Enum.map(map_groups, &Enum.chunk_every(&1, 3))

    # seeds_ranges
    [[79, 92]]
    # |> Enum.map(&MapSet.new/1)
    |> Enum.map(fn seeds_range ->
      Enum.reduce(map_groups, MapSet.new([seeds_range]), fn maps, current_ranges ->
        IO.inspect(%{maps: maps, ranges: current_ranges}, label: "GROUP")

        # Build next group ranges
        Enum.reduce(maps, [], fn map, _next_ranges ->
          IO.inspect(%{map: map, ranges: current_ranges}, label: "MAP")

          # next_ranges =
          Enum.reduce(current_ranges, current_ranges, fn range, acc ->
            IO.inspect(%{map: map, range: range}, label: "RANGE")
            # [range | acc]

            [src_start, dest_start, count] = map
            src_end = src_start + count - 1
            [current_start, current_end] = range

            # IO.inspect({range, map}, label: "check if in range")
            IO.inspect("check if in range")

            if(
              (current_start >= src_start and current_start < src_end) or
                (current_end >= src_start and current_end < src_end)
            ) do
              next_range = [
                dest_start + current_start - src_start,
                dest_start + current_start - src_start
              ]

              IO.inspect(next_range, label: "in range, remove current & add the mapping")

              acc |> MapSet.delete(range) |> MapSet.put(next_range)
            else
              acc
            end
          end)

          # next_ranges

          #   # for all current ranges check if fits map - in case of overlap add current range
          #   Enum.reduce(current_ranges, current_ranges, fn current_range, acc ->
          #     IO.inspect({current_range, map}, label: "check if in range")

          #     [dest, src, count] = map
          #     [src_min, src_max] = src_range = [src, src + count - 1]
          #     [dest_min, _dest_max] = dest_range = [dest, dest + count - 1]
          #     [current_min, current_max] = current_range

          #     IO.inspect(map, label: "map")
          #     IO.inspect(current_range, label: "current_range")
          #     IO.inspect({current_range, src_range, dest_range}, label: "map")

          #     if(
          #       (current_min >= src_min and current_min < src_max) or
          #         (current_max >= src_min and current_max < src_max)
          #     ) do
          #       IO.inspect(
          #         "#{current_min}, #{current_max} => #{dest_min + current_min - max(1, src_min)}, #{dest_min + current_max - src_min}",
          #         label: "IN RANGE"
          #       )

          #       [
          #         [dest_min + current_min - max(1, src_min), dest_min + current_max - src_min]
          #         | acc -- [current_range]
          #       ]
          #     else
          #       acc
          #     end
          #   end)
        end)
      end)
    end)
    |> List.flatten()
    |> Enum.min()
  end
end

# 35 = Task5.solve1(Task5.test_input())
# Task5.solve1(Api.get_input(5)) |> IO.inspect(label: "5.1")

46 = Task5.solve2(Task5.test_input())
# Task5.solve2(Api.get_input(5)) |> IO.inspect(label: "5.2")
```

## Task 6

```elixir
defmodule Task6 do
  def test_input,
    do: """
    Time:      7  15   30
    Distance:  9  40  200
    """

  def solve1(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(
      &(~r/\b\d+\b/
        |> Regex.scan(&1)
        |> Enum.map(fn match -> match |> hd() |> String.to_integer() end))
    )
    |> Enum.zip()
    |> Enum.reduce([], fn {time, record_distance}, winning_counts ->
      [
        Enum.reduce(1..(time - 1), 0, fn hold_time, winning_count ->
          distance = hold_time * (time - hold_time)
          if distance > record_distance, do: winning_count + 1, else: winning_count
        end)
        | winning_counts
      ]
    end)
    |> Enum.product()
  end

  def solve2(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(
      &(~r/\b\d+\b/
        |> Regex.scan(&1)
        |> Enum.map(fn match -> hd(match) end)
        |> Enum.join()
        |> String.to_integer())
    )
    |> then(fn [time, record_distance] ->
      Enum.reduce(1..(time - 1), 0, fn hold_time, winning_count ->
        distance = hold_time * (time - hold_time)
        if distance > record_distance, do: winning_count + 1, else: winning_count
      end)
    end)
  end
end

288 = Task6.solve1(Task6.test_input())
Task6.solve1(Api.get_input(6)) |> IO.inspect(label: "6.1")

71503 = Task6.solve2(Task6.test_input())
Task6.solve2(Api.get_input(6)) |> IO.inspect(label: "6.2")
```
