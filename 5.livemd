# Advent of Code 2023

```elixir
Mix.install([
  {:memoize, "~> 1.4"},
  {:tesla, "~> 1.8"},
  {:kino, "~> 0.11.3"}
])

Kino.configure(inspect: [limit: :infinity, charlists: :as_lists])

alias Kino, as: IO

defmodule Api do
  use Tesla
  use Memoize

  @session System.get_env("AOC_SESSION")

  plug(Tesla.Middleware.BaseUrl, "https://adventofcode.com/2023/day/")
  plug(Tesla.Middleware.Headers, [{"cookie", "session=#{@session}"}])

  defmemo get_input(day) do
    {:ok, response} = get("#{day}/input")
    response.body
  end
end

:ok
```

## Task 5

```elixir
defmodule Task5 do
  def test_input,
    do: """
    seeds: 79 14 55 13

    seed-to-soil map:
    50 98 2
    52 50 48

    soil-to-fertilizer map:
    0 15 37
    37 52 2
    39 0 15

    fertilizer-to-water map:
    49 53 8
    0 11 42
    42 0 7
    57 7 4

    water-to-light map:
    88 18 7
    18 25 70

    light-to-temperature map:
    45 77 23
    81 45 19
    68 64 13

    temperature-to-humidity map:
    0 69 1
    1 0 69

    humidity-to-location map:
    60 56 37
    56 93 4
    """

  def solve1(input) do
    [seeds | map_groups] =
      input
      |> String.split("\n\n", trim: true)
      |> Enum.map(&(Regex.scan(~r/\b\d+\b/, &1) |> Enum.map(fn [a] -> String.to_integer(a) end)))

    map_groups = Enum.map(map_groups, &Enum.chunk_every(&1, 3))

    seeds
    |> Enum.map(fn seed ->
      Enum.reduce(map_groups, seed, fn maps, current_range ->
        Enum.reduce_while(maps, current_range, fn map, current_value ->
          [dest, src, count] = map

          if src <= current_value and current_value < src + count do
            {:halt, dest + current_value - src}
          else
            {:cont, current_value}
          end
        end)
      end)
    end)
    |> Enum.min()
  end

  def solve2(input) do
    [seeds | map_groups] =
      input
      |> String.split("\n\n", trim: true)
      |> Enum.map(&(Regex.scan(~r/\b\d+\b/, &1) |> Enum.map(fn [a] -> String.to_integer(a) end)))

    seeds_ranges =
      Enum.chunk_every(seeds, 2)
      |> Enum.map(fn [start, count] -> start..(start + count - 1) end)
      |> IO.inspect()

    map_groups_ranges =
      Enum.map(map_groups, fn group ->
        Enum.chunk_every(group, 3)
        |> Enum.map(fn [dest, src, count] ->
          {src..(src + count - 1), dest..(dest + count - 1)}
        end)
      end)
      |> IO.inspect()

    Enum.each([79..92], fn seed_range ->
      IO.inspect(seed_range, label: "seed range")

      Enum.reduce(map_groups_ranges, [seed_range], fn map_group_ranges, check_ranges ->
        IO.inspect("#{map_group_ranges |> Enum.map(&inspect/1)} map group")
        IO.inspect(check_ranges, label: "map group check ranges")

        # THIS LOOP SHOULD RETURN CHECK RANGES FOR NEXT GROUP 
        Enum.reduce(map_group_ranges, {check_ranges, []}, fn map_group_range,
                                                             {check_ranges,
                                                              next_group_check_ranges} ->
          # seed_start..seed_end = seed_range
          {src_range, dest_range} = map_group_range

          {src_start..src_end, dest_start.._} = {src_range, dest_range}

          IO.inspect(src_start..src_end, label: "map range")
          # IO.inspect(
          #   "is #{inspect(seed_range)} in #{inspect(src_range)}?: #{!Range.disjoint?(seed_range, src_range)}"
          # )

          IO.inspect({check_ranges, next_group_check_ranges},
            label: "check ranges, next group check ranges"
          )

          # if contained fully -> mapped range into acc, end check
          # if contained partially -> partial mapped range into acc, continue check with non-matched part
          # if not contained at all -> nothing into acc, continue check with full 

          # if(!Range.disjoint?(seed_range, src_range)) do
          #   contained_start..contained_end =
          #     contained_range =
          #     max(seed_start, src_start)..min(seed_end, src_end)

          #   # |> IO.inspect(label: "contained range")

          #   # |> IO.inspect(label: "offset")
          #   offset = dest_start - src_start

          #   mapped_range =
          #     (contained_start + offset)..(contained_end + offset)
          #     |> IO.inspect(label: "mapped_range")
          # else
          #   IO.inspect(seed_range, label: "mapped range")
          # end
        end)
        |> elem(1)

        # check_ranges
      end)
    end)
  end
end

# 35 = Task5.solve1(Task5.test_input())
# Task5.solve1(Api.get_input(5)) |> IO.inspect(label: "5.1")

Task5.solve2(Task5.test_input())
# 46 = Task5.solve2(Task5.test_input())
# Task5.solve2(Api.get_input(5)) |> IO.inspect(label: "5.2")
```
